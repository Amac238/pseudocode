Provide all the code and written answers in a file named stacks_and_queues.txt:

a) What is the main difference between a stack and a queue?
A stack handles requests based on a LIFO approach (last in first out), while a queue uses a FIFO approach (first in first out)

b) What are the similarities between stacks and queues?
Stacks and queues allow engineers to rank tasks, create an order of operations, and support system functions.

Imagine you are an engineer tasked with implementing the UNDO and REDO options in a word processor such as Microsoft Word.
Which data structure would you use for each option and why?
c) For both UNDO  and Redo I would use a stack structure- the first action that should appear is the last one that was done aka LIFO: 

 when we perform the Undo, we want to undo the MOST RECENT EDIT THAT HAS NOT BEEN UNDONE 
 same way, when we perform a Redo, we want to REDO THE MOST RECENT UNDO THAT HAS NOT BEEN REDONE. Again, we need LIFO access to the Undo operations. We also need to use two stacks, one to keep the edit history, and one to keep the Undo history.


Programming Questions
You may program the following question in any language of your choice. Before you begin coding,
write out a plan as to how you will solve the question.

//Given a string, reverse it using a stack. For example, the string "Bloc!" should be converted to "!colB".

var letters =[];
var myWord = 'Bloc!';
var reverseWord= '';

  	for (var i=0; i<myWord.length; i++){
  	    letters.push(myWord[i]);
		}
		for (var i=0; i<myWord.length; i++){
  		  reverseWord += letters.pop();
		}

console.log (reverseWord);


//Implement the pop method of a stack using one queue.
//Make a FIFO data structure mirror the functionality of a LIFO data structure.
//Since the internal list is not the same as defined in the checkpoint, it may help to rewrite the pseudocode first.
//To delete an item, take all of the elements in the queue one at a time and put them at the end of the queue,
//except for the last one which should be removed and returned.

A.  
var shiftReturn =function (queue){
    var firstToGo=[];        	 
    var lastToReturn=[];     
    for ( let i=0; i<queue.length; i++){ 
        if( i!==queue.length -1){  
            firstToGo=queue.shift();   
            queue.push(firstToGo);    
            console.log(queue);
        } else {
            lastToReturn=queue.shift();   
            console.log(queue);
        }
    } 
      return lastToReturn;           
}

shiftReturn([‘ana','ella’,’bob’]);
  ["ella", "bob", "ana"]
  ["bob", "ana", "ella"]
  ["ana", "ella"]
  "bob"

B.  class Stack {
    constructor(){
     this.pop = function(queue){
       var newQueue = [];
       var itemToRemove = [];

       for(var i=0;i<queue.length; i++){
         if(i==queue.length-1){
           itemToRemove.push(queue[i]);
         }else{
           newQueue.push(queue[i]);
         }
       }

       return itemToRemove;   

     }
   }
}

var stack = new Stack();
console.log(stack.pop([1,2,3]);

//Implement the enqueue and dequeue methods defined in the checkpoint inside your own Queue class.

class Queue {
   constructor(){
     this.elements = []
   }
 // enqueue
  enqueue(element)
{
    this.elements.push(element);
}
  // dequeue
  dequeue()
  {
    this.elements.shift();
   }
}
var queue = new Queue();
//test
queue.enqueue("a")
queue.enqueue("b")
console.log(queue)
queue.dequeue()
console.log(queue)